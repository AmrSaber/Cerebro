the face detection step is an essential step before facial expression recognition, as we must first extract the faces from the image before further used for feature extraction (HOG and landmarks) then it's passed to the model.
\newline
we tried multiple face detection approaches that are discussed below.
\subsubsection{lBP classifier face detector}

\paragraph{theory}
Local Binary Pattern (LBP) features have performed very well in various applications, including texture classification and segmentation, image retrieval and surface inspection, The original LBP operator labels the pixels of an image by thresholding the 3-by-3 neighborhood of each pixel with the
center pixel value and considering the result as a binary number.
Figure \ref{fig:LBP_calculation} shows an example of LBP calculation. 

\begin{figure}
	\centering
	\includegraphics{images/LBP_classifier.png}
	\caption{Example of LBP calculation}
	\label{fig:LBP_calculation}
\end{figure}

\paragraph{performance}
we used the openCV implementation of the LBP classifier, among other methods we tried this was by far the the fastest one, it has an average execution time of ---- ms, this execution time and performance makes it suitable for mobile apps and real time applications alot, however it's very lacking in accuracy and when it comes to small faces mostly wouldn't detect them at all. 

\subsubsection{HAAR classifier face detector}

\paragraph{theory}
Object Detection using Haar feature-based cascade classifiers is an effective object detection method proposed by Paul Viola and Michael Jones\cite{haar}, It is a machine learning based approach where a cascade function is trained from a lot of positive and negative images. It is then used to detect objects in other images.

Initially, the algorithm needs a lot of positive images (images of faces) and negative images (images without faces) to train the classifier, Then we need to extract features from it, For this, Haar features shown in the below image are used, They are just like our convolutional kernel. Each feature is a single value obtained by subtracting sum of pixels under the white rectangle from sum of pixels under the black rectangle.

this classifier divides uses multiple sub weak classifiers to detect multiple features in the face, each of those classifiers has its own threshold value and was trained separately on the given images.
but there are too many features (up to 160000+) which would basically be very time consuming, so we a cascade style classifier, the point of this is that we don't need to test for all features in a window, if the strongest feature isn't there, then we can simply discard it, after few features have been tested we would end up with considerably few windows that can be face candidates, hence greatly increasing the performance, once enough amount of features is found we can accept the candidate window as a face.

\paragraph{performance}
we used the openCV implementation of the HAAR classifier, this classifier is quite close in structure and operation to LBP however it has higher accuracy than LBP, however it comes at the cost of execution time which greatly increased to ----, it's still possible to work with it for real time at soft constraints.


\subsubsection{Dlib face detector}
\paragraph{theory}
\paragraph{performance}
this is a pre-trained model within the Dlib library, its accuracy can be controlled by an integer input parameter the higher the value the more the accuracy, however this comes at the cost of execution time that greatly increase as well, after experimentation with it we found value 2 to be good enough, it gives accuracy that is superior to that of HAAR classifier with execution time that's not noticeably larger.


\subsubsection{PCN face detector}
\paragraph{Brief}
it's a rotation invariant face detector made based on Progressive Calibration Networks \cite{PCN}, this approach is one of the most effective approaches to the problem of rotation invariant face detection, it was implemented in c++ using libraries like openCV and Caffe.
\paragraph{theory}
The PCN detector diagram in Figure \ref{fig:LBP_calculation}, Given an image, all face candidates are obtained according to the sliding window and image pyramid principle, and each candidate window goes through the detector stage by stage, In each stage of PCN, the detector simultaneously rejects most candidates with low face confidences, regresses the bounding boxes of remaining face candidates, and calibrates the RIP orientations of the face candidates. After each stage, non-maximum suppression (NMS) is used to merge those highly overlapped candidates as most existing methods do.
\begin{figure}
	\centering
	\includegraphics[width=\textwidth]{images/PCN_archOverview.png}
	\caption{overview about PCN architecture \cite{PCN}}
	\label{fig:PCN_archOverview}
\end{figure}
\paragraph{performance}
this face detection method was by far the best, it was implemented using openCV and Caffe library, its performance in terms of execution time and accuracy surpass the other methods we tried, it even has two main advantages over them as it can't only detect small faces of with high accuracy, it's even rotation invariant and this particular point is what makes it very strong tool.

\subsubsection{results}